Reflection Session Notes

1. Classes
----------
Class : Object :: Blueprint : Building
blueprint or prototype from which objects are created.
It combines feilds and member methods into a single unit.
Decleration: with keyword class followed by a identifier (class name).
	////[access modifier] - [class] - [identifier]////
The decleration of class happens in following order: 
	*Modifiers: By default modifier of class is internal.
	*Keyword class: A class keyword is used to declare the type class.
	*Class Identifier: The variable of type class is provided.
						//Naming Convention: first letter should capital
	*Base class or Super class: The name of the class’s parent (superclass), if any, preceded by the : (colon). This is optional.
	*Interfaces: A comma-separated list of interfaces implemented by the class, if any, preceded by the : (colon). A class can implement more than one interface. This is optional.
	*Body: The class body is surrounded by { } (curly braces).

2. Objects:
-----------
Instance of your class. 
object contains data in form of feilds, code in form of methods.

Decleration: (Aka instantiating a class)
a class can be instantiated any number of times, where each instance is independent of each other.

3. Access Specifiers
--------------------

it is used to specify accessibility of a types and members.
	*Public :  makes a class (including nested classes), property, method or field available to every consumer.
	class A {
	
	public void MethodA(){
	
	}
	}
	class Program
	{
		static void Main(string[] args)
		{
			A objClassTest = new A();

			objClassTest.MethodA(); // valid code to access.
		}
	}
	*Private: marks properties, methods, fields and nested classes for use inside the class only.
	///If we make constructor private -> that class cant be access from outside, object can't be created for it.
		class NumberClass
		{
			private int number = 10;
		}
 
		class Program
		{
			static void Main(string[] args)
			{
				NumberClass num = new NumberClass();
				Console.WriteLine(num.number); // Error. We can't access the number variable because 
				// it has the private access modifier and its only accessible in the NumberClass class
			}
		}
		
	*Internal:  makes a class (including nested classes), property, method or field available to every consumer in the same assembly
	*Protected:  marks field, methods properties and nested classes for use inside the same class and derived classes only.

			class NumberClass
			{
				protected int number = 10; //we can access this variable inside this class
			}
			 
			class DerivedClass: NumberClass //this is inheritance. DerivedClass derives from the NumberClass class
			{
				void Print()
				{
					Console.WriteLine(number); //we can access it in this class as well because it derives from the NumberClass class
				}
			}
			 
			class Program
			{
				void Print()
				{
					NumberClass num = new NumberClass();
					Console.WriteLine(num.number); // Error. The number variable is inaccessible due to its protection level. 
										   // The Program class doesn't derive from the NumberClass
				}
			}
	*Protected Internal:  keyword marks field, methods, properties and nested classes for use inside the same assembly 
	or derived classes in another assembly.
	//First Project (ASSEMBLY)
			public class NumberClassInFirstProject
			{
				protected internal int number = 10; //we can access this variable inside this class
			}
			 
			class ProgramInFirstProject
			{
				void Print()
				{
					NumberClassInFirstProject num = new NumberClassInFirstProject();
					Console.WriteLine(num.number); // This is OK. Anywhere in this project (assembly) we can access the number variable.
				}
			}
			 
			//Second project (ASSEMBLY)
			class Program: NumberClassInFirstProject //Inheritance
			{
				void Print()
				{
					Console.WriteLine(number); //This is OK as well. The class Program derives from the NumberClassInFirstProject clas.
				}
			}

	** if no access specifier is mentioned then the default access specifier is internal.
	
3. Properties:
provides a flexible mechanism to read, write.
Problems with variables : 
	1>If the members of a class are private then how another class in C# will be able to read, write, 
	or compute the value that field.
	2>If the members of the class are public then another class may misuse that member.

	<access_modifier> <return_type> <property_name>
		{
				get { // body }
				set { // body }
		}
		
**Use of property encapsulated the way the we access data.

string MyProperty { get; set; } -> AKA auto-implemented way. we can extend it also
			set
		{
			if (string.IsNullOrWhiteSpace(value))
				throw new ArgumentNullException();

			_myProperty = value;
		}


we can have different access specifiers for getters and setter
Eg : 
private int m_myInt = -1;
public int MyProperty
{
get {return m_myInt;}


set {m_myInt = value;}
}



4. Encapsulation: Binding of data memebers and memeber functions in a single unit.
Prevents access to implementation details.
Generally, in c# the encapsulation is used to prevent an alteration of code (data) accidentally from the outside of functions.


5. List : represents a collection of strongly typed objects that can be accessed by index.
list.Add
list.AddRange
Insert at a position : authors.Insert(postion, "Bill Author")
authors.InsertRange(2, newAuthors);
list.remove
list.removeAT()
list.removerange(pos, range)
list.clear() //removes all items
list.indexof(item) returns -1 if not found else pos
list.sort
list.reverse

	public static void Main()
        {
 
            List<int> list = new List<int>();
            list.Add(1);
            list.Add(2);
            list.Add(3);
 
            foreach (int item in list) // Loop through List with foreach
            {
                Console.WriteLine(item);
            }
 
            for (int i = 0; i < list.Count; i++) // Loop through List with for
            {
                Console.WriteLine(list[i]);
            }
        }

6. ArrayList -> not strongly typed.
Used to store data dynamically
Declaeration: ArrayList a1 = new ArrayList()
Adding element: ArrayList.add(element)
		a1.add(1) – This will add an Integer value to the collection
		a1.add("Example") – This will add a String value to the collection
		a1.add(true) 
		Console.WriteLine(a1[0]);
		ArrayList.Count() 
		ArrayList.Contains(element)  -> returns true or false;
		
		should not be used
		
		  public static void Main() { 
    ArrayList al = new ArrayList(); 
     
    Console.WriteLine("Adding 6 elements"); 
    // Add elements to the array list 
    al.Add('C'); 
    al.Add('A'); 
    al.Add('E'); 
    al.Add('B'); 
    al.Add('D'); 
    al.Add('F'); 
 
    // Use foreach loop to display the list. 
    Console.Write("Contents: "); 
    foreach(char c in al) 
      Console.Write(c + " "); 
    Console.WriteLine("\n"); 
 
  }
		

7. Dictionary: 
The Dictionary<TKey, TValue> collection in C#.
Dictionary<int, string> dict = new Dictionary<int, string>();

ADD: 
IDictionary<int, string> dict = new Dictionary<int, string>();
dict.Add(1,"One");
dict.Add(2,"Two");
dict.Add(3,"Three");


Items can be added at dict intitalization time as well.

IDictionary<int, string> dict = new Dictionary<int, string>()
                                            {
                                                {1,"One"},
                                                {2, "Two"},
                                                {3,"Three"}
                                            };
											

Accessing element:
foreach (KeyValuePair<int, string> item in dict)
{
    Console.WriteLine("Key: {0}, Value: {1}", item.Key, item.Value);
}



for (int i = 0; i < dict.Count; i++)
{
    Console.WriteLine("Key: {0}, Value: {1}", 
                                            dict.Keys.ElementAt(i), 
                                            dict[ dict.Keys.ElementAt(i)]);
}

.containsKey
.containsValue
dict[key]

foreach(KeyValuePair<string, string> entry in myDictionary)
{
    // do something with entry.Value or entry.Key
}


8 HASTABLE
Hashtable class represents a collection of key-and-value pairs that are organized based on the hash code of the key. 
Hashtable ht = new Hashtable()
HashTable.add("key","value")
Hashtable.Containskey(key)
ht[key]

   Hashtable ht = new Hashtable();
         
         ht.Add("001", "Zara Ali");
         ht.Add("002", "Abida Rehman");
         ht.Add("003", "Joe Holzner");
         ht.Add("004", "Mausam Benazir Nur");
         ht.Add("005", "M. Amlan");
         ht.Add("006", "M. Arif");
         ht.Add("007", "Ritesh Saikia");
         
         if (ht.ContainsValue("Nuha Ali")) {
            Console.WriteLine("This student name is already in the list");
         } else {
            ht.Add("008", "Nuha Ali");
         }
         
         // Get a collection of the keys.
         ICollection key = ht.Keys;
         
         foreach (string k in key) {
            Console.WriteLine(k + ": " + ht[k]);
         }
         Console.ReadKey();
      }
   }
}

Dictionary<TKey, TValue> is a generic type, Hashtable is not.
 That means you get type safety with Dictionary<TKey, TValue>, because you can't insert any random object into it, and you don't have to cast the values you take out.


Check if it contains a value : Hashtable.ContainsValue(value)
Dict is generic and hashtable is non generic.
In Hashtable, you can store key/value pairs of the same type or of the different type.	
In Dictionary, you can store key/value pairs of same type.
In Hashtable, there is no need to specify the type of the key and value.	
In Dictionary, you must specify the type of key and value.
Dict has faster data retrievals


9. Interface: 
Looks like a class but we dont provide implemenation. 
An interface is used to enforce the presence of a method in any class that 'implements' it.
No acess specifier can be used against an interface

An Interface's function known as a "contract" of functionality. It means that it declares properties and methods but
it doesn't implement them.
So unlike classes Interfaces:
Can't be instantiated
Can't have any functionality
Can only contain methods * (Properties and Events are methods internally)
Inheriting an interface is called "Implementing"
You can inherit from 1 class, but you can "Implement" multiple Interfaces


10. Abstract Classes: used to define a base class . When a class is marked abstract it can't be instatantiated. 
Animal class is abastract method descriptions.
A method, property, or event marked with the keyword abstract indicates that the implementation for that
member is expected to be provided in a subclass for this use oveeride keyword.
abstract class Animal
{
 public abstract string Name { get; set; }
}
public class Cat : Animal
{
 public override string Name { get; set; }
}
public class Dog : Animal
{
 public override string Name { get; set; }
}

12. Abstract class vs Interface
-------------------------------
abstract class allows you to create a func that sub classes can implement or overide
abstract classes are partially implemented or not implemented as all.
abstract classes can have constructors.

11. Inheritance: By default every class inherits from object class. 
In this one class inherits member and methods from another class
	1>Superclass: class whose feature is inherited
	2>subclass: class inheriting other class
	3>resuability : inheritance supports concepts of resuasbility.
	
	class derviedclass: base class
	{}
	
	single inheritance: when one derived class inherits from a single base class.
	multilevelinheritance
	heirarchial inheritance: one super class and multiple base class. 
	multiple inheritace: c# doesnt support multiple inheritace. >1 base class.
	
	Inheriting constructed :only members and functions are inherited so constructor is not inherited 
	
	
	EG: 
	
	class Animal
		{
		 protected string name;
		 public Animal()
		 {
		 Console.WriteLine("Animal's default constructor");
		 }
		 public Animal(string name)
		 {
		 this.name = name;
		 Console.WriteLine("Animal's constructor with 1 parameter");
		 Console.WriteLine(this.name);
		 }
		}
		class Dog : Animal
		{
		 public Dog() : base()
		 {
		 Console.WriteLine("Dog's default constructor");
		 }
		 public Dog(string name) : base(name)
		 {
		 Console.WriteLine("Dog's constructor with 1 parameter");
		 Console.WriteLine(this.name);
		 }
		}
		
		
14. Static: 
	1. Static class: static class comtains static data members, static methods, and a static constructor.
		Not able to create objects. they are sealed so it cant be inherited.
	2. Static variable : When a variable is declared as static, 
						then a single copy of the variable is created and shared among all objects at the class level. 
						using System; 
  
			class Vehicle { 
			  
				// Creating static variable 
				// Using static keyword 
				public static string Model_color = "Black"; 
			} 
			  
			// Driver Class 
			public class GFG { 
			  
				// Main Method 
				static public void Main() 
				{ 
			  
					// Accessing the static variable 
					// using its class name 
					Console.WriteLine("Color of XY model is  : {0} ", 
												Vehicle.Model_color); 
				} 
			} 
	3. 
	